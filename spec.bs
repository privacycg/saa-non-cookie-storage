<pre class="metadata">
Title: Extending Storage Access API (SAA) to non-cookie storage
Shortname: saa-non-cookie-storage
Repository: privacycg/saa-non-cookie-storage
URL: https://privacycg.github.io/saa-non-cookie-storage/
Editor: Ari Chivukula, w3cid 132484, Google https://google.org, arichiv@google.com
Editor: Johann Hofmann, w3cid 120436, Google https://google.com, johannhof@google.com
Abstract: This extends the Storage Access API to enable content in cross-site iframes to request access to first-party data beyond cookies.
Status Text: This specification is intended to be merged into the HTML Living Standard. It is neither a WHATWG Living Standard nor is it on the standards track at W3C.
Text Macro: LICENSE <a href=https://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License</a>
Group: privacycg
Status: CG-DRAFT
Level: None
Markup Shorthands: markdown yes, css no
Complain About: accidental-2119 true
</pre>

<pre class=link-defaults>
spec:html; type:dfn; for:site; text:same site
spec:url; type:interface; text:URL
</pre>
<pre class="anchors">
spec: html; urlPrefix: https://html.spec.whatwg.org/
    type: dfn
        for: html
            text: web storage; url: #webstorage
            text: sessionStorage; url: #dom-sessionstorage
            text: localStorage; url: #dom-localstorage
            text: broadcast channel; url: #broadcasting-to-other-browsing-contexts
            text: new broadcastchannel; url: #dom-broadcastchannel
spec: storage-access; urlPrefix: https://privacycg.github.io/storage-access/
    type: dfn
        for: environment
            text: has storage access; url: #environment-has-storage-access
        text: unpartitioned data; url: #unpartitioned-data
        text: first-party-site context; url: #first-party-site-context
        text: third party context; url: #third-party-context
spec: indexed-db; urlPrefix: https://www.w3.org/TR/IndexedDB/
    type: dfn
        text: indexed database api; url:
spec: web-locks; urlPrefix: https://www.w3.org/TR/web-locks/
    type: dfn
        text: web locks api; url:
        text: locks; url: #dom-navigatorlocks-locks
spec: service-worker; urlPrefix: https://w3c.github.io/ServiceWorker/
    type: dfn
        text: cache storage; url: #cache-objects
        text: caches; url: #global-caches-attribute
spec: storage; urlPrefix: https://storage.spec.whatwg.org/
    type: dfn
        text: storage manager; url:
spec: file-system; urlPrefix: https://fs.spec.whatwg.org/
    type: dfn
        text: file system; url:
spec: file-api; urlPrefix: https://www.w3.org/TR/FileAPI/
    type: dfn
        text: file api; url:
        text: createobjecturl; url: #dfn-createObjectURL
        text: revokeobjecturl; url: #dfn-revokeObjectURL
</pre>

<pre class=biblio>
{
    "STORAGE-ACCESS": {
        "authors": [
            "Benjamin VanderSloot",
            "Johann Hofmann",
            "Anne van Kesteren"
        ],
        "href": "https://privacycg.github.io/storage-access/",
        "publisher": "W3C",
        "title": "The Storage Access API"
    },
    "STORAGE-PARTITIONING": {
        "authors": [
            "Privacy Community Group"
        ],
        "href": "https://privacycg.github.io/storage-partitioning/",
        "publisher": "W3C",
        "title": "Client-Side Storage Partitioning"
    }
}
</pre>

<section class="non-normative">

<h2 id="intro">Introduction</h2>

<em>This section is non-normative.</em>

The Storage Access API (SAA) enables content inside <{iframe}>s to request and be granted access to their client-side storage, so that embedded content which relies on having access to client-side storage can work in such User Agents. [[STORAGE-ACCESS]]

This specification extends the client-side storage available beyond cookies.

</section>

<h2 id="extending-saa-to-non-cookie-storage">Extending SAA to non-cookie storage</h2>

This specification defines a method to request access to [=unpartitioned data=] beyond just cookies ({{Document/requestStorageAccess(types)}}), and a method to check if cookie access has specifically been granted ({{Document/hasUnpartitionedCookieAccess()}}).

<div class=example>

Alex visits `https://social.example/`. The page sets a some local storage. This local storage has been set in a [=first-party-site context=].

```javascript
window.localStorage.setItem("userid", "1234");
```

Later on, Alex visits `https://video.example/`, which has an <{iframe}> on it which loads `https://social.example/heart-button`. In this case, the `social.example` {{Document}} |doc| is in a [=third party context=], and the local storage set previously might or might not be visible depending on User Agent storage access policies.

Script in the <{iframe}> can call |doc|`.`{{Document/requestStorageAccess(types)}} to request access.

```javascript
let handle = await document.requestStorageAccess({localStorage: true});
let userid = handle.localStorage.getItem("userid");
```

</div>

<h3 id="document-changes">Changes to {{Document}}</h3>

<pre class="idl">
dictionary StorageAccessTypes {
  boolean all = false;
  boolean cookies = false;
  boolean sessionStorage = false;
  boolean localStorage = false;
  boolean indexedDB = false;
  boolean locks = false;
  boolean caches = false;
  boolean getDirectory = false;
  boolean estimate = false;
  boolean createObjectURL = false;
  boolean revokeObjectURL = false;
  boolean BroadcastChannel = false;
};

interface StorageAccessHandle {
  readonly attribute Storage sessionStorage;
  readonly attribute Storage localStorage;
  readonly attribute IDBFactory indexedDB;
  readonly attribute LockManager locks;
  readonly attribute CacheStorage caches;
  Promise&lt;FileSystemDirectoryHandle> getDirectory();
  Promise&lt;StorageEstimate> estimate();
  DOMString createObjectURL((Blob or MediaSource) obj);
  undefined revokeObjectURL(DOMString url);
  BroadcastChannel BroadcastChannel(DOMString name);
};

partial interface Document {
  Promise&lt;boolean> hasUnpartitionedCookieAccess();
  Promise&lt;StorageAccessHandle> requestStorageAccess(StorageAccessTypes types);
};
</pre>

When invoked on {{Document}} |doc|, the <dfn export method for=Document><code>hasUnpartitionedCookieAccess()</code></dfn> method must run these steps:

1. Return the invocation of {{Document/hasStorageAccess()}} on |doc|.

Note:
Now that {{Document/requestStorageAccess(types)}} <span class=allow-2119>can</span> be used to request [=unpartitioned data=] with or without specifically requesting cookies, it <span class=allow-2119>must</span> be made clear that {{Document/hasStorageAccess()}} only returns true if [=first-party-site context=] cookies are accessable to the current document.
As a function name, {{Document/hasUnpartitionedCookieAccess()}} more clearly communicates this.
For now {{Document/hasStorageAccess()}} is not considered deprecated, but that <span class=allow-2119>may</span> be worth taking up in future.

When invoked on {{Document}} |doc|, the <dfn export method for=Document><code>requestStorageAccess(types)</code></dfn> method must run these steps:

1. Let |p| be [=a new promise=].
1. If |types|.{{StorageAccessTypes/all}} is `false` and |types|.{{StorageAccessTypes/cookies}} is `false` and |types|.{{StorageAccessTypes/sessionStorage}} is `false` and |types|.{{StorageAccessTypes/localStorage}} is `false` and |types|.{{StorageAccessTypes/indexedDB}} is `false` and |types|.{{StorageAccessTypes/locks}} is `false` and |types|.{{StorageAccessTypes/caches}} is `false` and |types|.{{StorageAccessTypes/getDirectory}} is `false` and |types|.{{StorageAccessTypes/estimate}} is `false` and |types|.{{StorageAccessTypes/createObjectURL}} is `false` and |types|.{{StorageAccessTypes/revokeObjectURL}} is `false` and |types|.{{StorageAccessTypes/BroadcastChannel}} is `false`:
    1. [=/Reject=] |p| with an "{{InvalidStateError}}" {{DOMException}}.
    1. Return |p|.
1. Let |requestUnpartitionedCookieAccess| be `true` if |types|.{{StorageAccessTypes/all}} is `true` or |types|.{{StorageAccessTypes/cookies}} is `true`, and `false` otherwise.
1. Let |accessPromise| be the result of running [=request storage access=] with |doc| with |requestUnpartitionedCookieAccess|.
1. If |accessPromise| [=/rejects=] with `reason` |r|:
    1. [=/Reject=] |p| with |r|.
1. Else:
    1. Let |handle| be a new object of type {{StorageAccessHandle}} with |types|.
    1. [=/Resolve=] |p| with |handle|.
1. Return |p|.

<h3 id="request-storage-access-changes">Changes to {{Document/requestStorageAccess()}}</h3>

Redefine {{Document/requestStorageAccess()}} to:
1. Return the result of running [=request storage access=] with |doc| and |requestUnpartitionedCookieAccess| being `true`.

Modify {{Document/requestStorageAccess()}} to instead be the algorithm <dfn export>request storage access</dfn> which takes a {{Document}} |doc| and a `boolean` argument |requestUnpartitionedCookieAccess|.

Modify {{Document/requestStorageAccess()}} at step 14.1.1.1.1 to read:

1. If |requestUnpartitionedCookieAccess| is `true`, then set <var ignore='monkeypatch'>global</var>'s [=environment/has storage access=] to true.

<h3 id="storage">Changes to various client-side storage mechanisms</h3>

For all of the following getters and functions, consider the |docForSAA| to be |doc| with the following modifications:

1. No existing storage mechanism caches on |doc| will be available on |docForSAA|.
1. Any storage mechanism caches made on |docForSAA| will not be added to |doc|.
1. When attempting to [=obtain a storage key=] the returned key will use [[STORAGE-PARTITIONING#relaxing-additional-keying]].

<h4 id="dom-storage">[=Web storage=]</h4>

When invoked on {{StorageAccessHandle}} |handle| with {{StorageAccessTypes}} |types| and {{Document}} |docForSAA|, the <dfn export getter for=StorageAccessHandle><code>sessionStorage</code></dfn> getter must run these steps:

1. If |types|.{{StorageAccessTypes/all}} is `false` and |types|.{{StorageAccessTypes/sessionStorage}} is `false`:
    1. Throw an "{{InvalidStateError}}" {{DOMException}}.
1. Return the invocation of [=html/sessionStorage=] on |docForSAA|.

When invoked on {{StorageAccessHandle}} |handle| with {{StorageAccessTypes}} |types| and {{Document}} |docForSAA|, the <dfn export getter for=StorageAccessHandle><code>localStorage</code></dfn> getter must run these steps:

1. If |types|.{{StorageAccessTypes/all}} is `false` and |types|.{{StorageAccessTypes/localStorage}} is `false`:
    1. Throw an "{{InvalidStateError}}" {{DOMException}}.
1. Return the invocation of [=html/localStorage=] on |docForSAA|.

<h4 id="indexed-db">[=Indexed Database API=]</h4>

When invoked on {{StorageAccessHandle}} |handle| with {{StorageAccessTypes}} |types| and {{Document}} |docForSAA|, the <dfn export getter for=StorageAccessHandle><code>indexedDB</code></dfn> getter must run these steps:

1. If |types|.{{StorageAccessTypes/all}} is `false` and |types|.{{StorageAccessTypes/indexedDB}} is `false`:
    1. Throw an "{{InvalidStateError}}" {{DOMException}}.
1. Return the invocation of {{WindowOrWorkerGlobalScope/indexedDB}} on |docForSAA|.

<h4 id="web-locks">[=Web Locks API=]</h4>

When invoked on {{StorageAccessHandle}} |handle| with {{StorageAccessTypes}} |types| and {{Document}} |docForSAA|, the <dfn export getter for=StorageAccessHandle><code>locks</code></dfn> getter must run these steps:

1. If |types|.{{StorageAccessTypes/all}} is `false` and |types|.{{StorageAccessTypes/locks}} is `false`:
    1. Throw an "{{InvalidStateError}}" {{DOMException}}.
1. Return the invocation of [=/locks=] on |docForSAA|.{{Navigator}}.

<h4 id="cache-storage">[=Cache Storage=]</h4>

When invoked on {{StorageAccessHandle}} |handle| with {{StorageAccessTypes}} |types| and {{Document}} |docForSAA|, the <dfn export getter for=StorageAccessHandle><code>caches</code></dfn> getter must run these steps:

1. If |types|.{{StorageAccessTypes/all}} is `false` and |types|.{{StorageAccessTypes/caches}} is `false`:
    1. Throw an "{{InvalidStateError}}" {{DOMException}}.
1. Return the invocation of [=/caches=] on |docForSAA|.

<h4 id="file-system">[=File System=]</h4>

When invoked on {{StorageAccessHandle}} |handle| with {{StorageAccessTypes}} |types| and {{Document}} |docForSAA|, the <dfn export method for=StorageAccessHandle><code>getDirectory()</code></dfn> method must run these steps:

1. Let |p| be [=a new promise=].
1. If |types|.{{StorageAccessTypes/all}} is `false` and |types|.{{StorageAccessTypes/getDirectory}} is `false`:
    1. [=/Reject=] |p| with an "{{InvalidStateError}}" {{DOMException}}.
1. Let |directoryPromise| be the result of running {{StorageManager/getDirectory()}} on |docForSAA|.{{Navigator}}.{{NavigatorStorage/storage}}.
1. If |directoryPromise| [=/rejects=] with `reason` |r|:
    1. [=/Reject=] |p| with |r|.
1. Else if |directoryPromise| [=/resolves=] with {{FileSystemDirectoryHandle}} |f|:
    1. [=/Resolve=] |p| with |f|.
1. Return |p|.

<h4 id="storage-manager">[=Storage Manager=]</h4>

When invoked on {{StorageAccessHandle}} |handle| with {{StorageAccessTypes}} |types| and {{Document}} |docForSAA|, the <dfn export method for=StorageAccessHandle><code>estimate()</code></dfn> method must run these steps:

1. Let |p| be [=a new promise=].
1. If |types|.{{StorageAccessTypes/all}} is `false` and |types|.{{StorageAccessTypes/estimate}} is `false`:
    1. [=/Reject=] |p| with an "{{InvalidStateError}}" {{DOMException}}.
1. Let |estimatePromise| be the result of running {{StorageManager/estimate()}} on |docForSAA|.{{Navigator}}.{{NavigatorStorage/storage}}.
1. If |estimatePromise| [=/rejects=] with `reason` |r|:
    1. [=/Reject=] |p| with |r|.
1. Else if |estimatePromise| [=/resolves=] with {{StorageEstimate}} |e|:
    1. [=/Resolve=] |p| with |e|.
1. Return |p|.

<h4 id="file-api">[=File API=]</h4>

When invoked on {{StorageAccessHandle}} |handle| with {{StorageAccessTypes}} |types|, {{Document}} |docForSAA|, and {{Blob}} or {{MediaSource}} |obj|, the <dfn export method for=StorageAccessHandle><code>createObjectURL(obj)</code></dfn> method must run these steps:

1. If |types|.{{StorageAccessTypes/all}} is `false` and |types|.{{StorageAccessTypes/createObjectURL}} is `false`:
    1. Throw an "{{InvalidStateError}}" {{DOMException}}.
1. Return the invocation of [=/createObjectURL=] on |docForSAA|.{{URL}} with |obj|.

When invoked on {{StorageAccessHandle}} |handle| with {{StorageAccessTypes}} |types|, {{Document}} |docForSAA|, and {{DOMString}} |url|, the <dfn export method for=StorageAccessHandle><code>revokeObjectURL(url)</code></dfn> method must run these steps:

1. If |types|.{{StorageAccessTypes/all}} is `false` and |types|.{{StorageAccessTypes/revokeObjectURL}} is `false`:
    1. Throw an "{{InvalidStateError}}" {{DOMException}}.
1. Return the invocation of [=/revokeObjectURL=] on |docForSAA|.{{URL}} with |url|.

<h4 id="broadcast-channel">[=Broadcast Channel=]</h4>

When invoked on {{StorageAccessHandle}} |handle| with {{StorageAccessTypes}} |types|, {{Document}} |docForSAA|, and {{DOMString}} |name|, the <dfn export method for=StorageAccessHandle><code>BroadcastChannel(name)</code></dfn> method must run these steps:

1. If |types|.{{StorageAccessTypes/all}} is `false` and |types|.{{StorageAccessTypes/BroadcastChannel}} is `false`:
    1. Throw an "{{InvalidStateError}}" {{DOMException}}.
1. Return the invocation of [=new BroadcastChannel=] on |docForSAA| with |name|.

<h4 id="shared-worker">Shared Worker</h4>

TBD

<h2 id="privacy">Security & Privacy considerations</h2>

In extending an existing access-granting API, care must be taken not to open additional security issues or abuse vectors relative to comprehensive cross-site cookie blocking and storage partitioning.
Except for Service Workers (which will not be supported in this extension) non-cookie storage and communication APIs don't enable any capability that could not be built with cookie access alone.

For more detailed discussions see [[STORAGE-ACCESS#privacy]] and [[STORAGE-ACCESS#security]].
